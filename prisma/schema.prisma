generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  EDITOR
  REVIEWER
}

enum CountryStatus {
  DRAFT
  VERIFIED
  PUBLISHED
}

enum DrivingSide {
  LEFT
  RIGHT
}

enum IssueStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum IssuePriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String?
  passwordHash String
  role         UserRole @default(EDITOR)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  updatedCountries Country[]  @relation("CountryUpdatedBy")
  verifiedCountries Country[] @relation("CountryVerifiedBy")
  auditLogs        AuditLog[]

  @@map("users")
}

model Country {
  id                String        @id @default(cuid())
  name              String
  iso2              String        @unique @db.Char(2)
  iso3              String?       @db.Char(3)
  nameLocal         String?       // local-language name e.g. "Deutschland"
  continent         String?       // e.g. "Europe"
  flag              String?
  drivingSide       DrivingSide   @default(RIGHT)
  summary           String?       @db.Text
  commonTraps       Json?         // string[] of common traveler mistakes
  rentalAndIdpNotes String?       @db.Text
  idpRequirement    String?       @db.Text
  dataCoverage      String?       // "high" | "medium" | "low"
  localeContent     Json?         // { de: { summary, commonTraps, rentalAndIdpNotes } }
  status            CountryStatus @default(DRAFT)
  verifiedStatus    String?
  lastVerifiedAt    DateTime?
  updatedById       String?
  verifiedById      String?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  updatedBy  User?    @relation("CountryUpdatedBy", fields: [updatedById], references: [id])
  verifiedBy User?    @relation("CountryVerifiedBy", fields: [verifiedById], references: [id])
  regions    Region[]
  rules      CountryRule[]
  sources    Source[]
  issues     IssueReport[]
  auditLogs  AuditLog[]    @relation("CountryAuditLogs")

  @@map("countries")
}

model Region {
  id        String   @id @default(cuid())
  countryId String
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  country         Country               @relation(fields: [countryId], references: [id], onDelete: Cascade)
  ruleOverrides   RegionRuleOverride[]
  sources         Source[]
  issues          IssueReport[]

  @@map("regions")
}

model RuleModule {
  key         String  @id
  name        String
  description String? @db.Text
  schemaHint  Json?

  countryRules        CountryRule[]
  regionRuleOverrides RegionRuleOverride[]
  sources             Source[]

  @@map("rule_modules")
}

model CountryRule {
  id              String   @id @default(cuid())
  countryId       String
  moduleKey       String
  structuredValue Json?
  textNotes       String?  @db.Text
  vehicleType     String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  country Country    @relation(fields: [countryId], references: [id], onDelete: Cascade)
  module  RuleModule @relation(fields: [moduleKey], references: [key])

  @@unique([countryId, moduleKey, vehicleType])
  @@map("country_rules")
}

model RegionRuleOverride {
  id            String   @id @default(cuid())
  regionId      String
  moduleKey     String
  overrideValue Json?
  textNotes     String?  @db.Text
  vehicleType   String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  region Region     @relation(fields: [regionId], references: [id], onDelete: Cascade)
  module RuleModule @relation(fields: [moduleKey], references: [key])

  @@unique([regionId, moduleKey, vehicleType])
  @@map("region_rule_overrides")
}

model Source {
  id            String    @id @default(cuid())
  countryId     String?
  regionId      String?
  moduleKey     String?
  title         String
  url           String
  publisher     String?
  publishedDate DateTime?
  notes         String?   @db.Text
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  country Country?    @relation(fields: [countryId], references: [id], onDelete: SetNull)
  region  Region?     @relation(fields: [regionId], references: [id], onDelete: SetNull)
  module  RuleModule? @relation(fields: [moduleKey], references: [key])

  @@map("sources")
}

model IssueReport {
  id        String        @id @default(cuid())
  countryId String?
  regionId  String?
  category  String
  message   String        @db.Text
  contact   String?
  status    IssueStatus   @default(OPEN)
  priority  IssuePriority @default(MEDIUM)
  tags      Json?         @default("[]")
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  country Country? @relation(fields: [countryId], references: [id], onDelete: SetNull)
  region  Region?  @relation(fields: [regionId], references: [id], onDelete: SetNull)

  @@map("issue_reports")
}

model AuditLog {
  id          String   @id @default(cuid())
  actorUserId String?
  entityType  String
  entityId    String
  action      String
  beforeValue Json?
  afterValue  Json?
  note        String?  @db.Text
  createdAt   DateTime @default(now())

  actorUser User?    @relation(fields: [actorUserId], references: [id], onDelete: SetNull)
  country   Country? @relation("CountryAuditLogs", fields: [entityId], references: [id], map: "audit_country_id")

  @@map("audit_logs")
}

/// Tracks failed login attempts for brute-force / credential-stuffing protection.
/// `identifier` is SHA-256(ip | "|" | email) â€” never stored in plaintext in the index.
/// Rows older than 30 days are lazily pruned in rate-limit.ts.
model LoginAttempt {
  id          String    @id @default(cuid())
  identifier  String    // SHA-256 hash of "ip|email"
  ip          String    // stored for audit/analysis, not indexed
  email       String    // lowercase email, stored for admin review
  failCount   Int       @default(0)
  lockedUntil DateTime? // null = not locked
  lastAttempt DateTime  @default(now())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([identifier])
  @@map("login_attempts")
}

